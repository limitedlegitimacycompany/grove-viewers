<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ðŸŽµ quartet</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽµ</text></svg>">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
  :root {
    --bg: #080c08;
    --bg-surface: #0e150e;
    --bg-panel: #111a11;
    --bg-input: #1a241a;
    --border: #2a3a2a;
    --text: #e8e8e0;
    --text-muted: #6a7a6a;
    --text-dim: #4a5a4a;
    --moss-color: #4ade80;
    --wren-color: #f59e0b;
    --kit-color: #f472b6;
    --sol-color: #facc15;
    --user-color: #9ca3af;
    --system-color: #5a6a5a;
    --scrollbar-thumb: #2a3a2a;
    --scrollbar-track: transparent;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'JetBrains Mono', monospace;
    font-size: 14px;
    overflow: hidden;
    -webkit-text-size-adjust: 100%;
  }

  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
  ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }

  /* Password Screen */
  #password-screen {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.97);
    display: flex; align-items: center; justify-content: center;
    z-index: 200;
    backdrop-filter: blur(12px);
  }
  #password-screen.hidden { display: none; }
  .pw-card {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 40px 32px;
    max-width: 380px; width: 90%;
    text-align: center;
  }
  .pw-card h1 { font-size: 36px; margin-bottom: 4px; color: var(--moss-color); }
  .pw-card .subtitle { color: var(--text-muted); margin-bottom: 28px; font-size: 13px; }
  .pw-form { display: flex; gap: 8px; }
  .pw-form input {
    flex: 1; padding: 12px 16px;
    background: var(--bg-input); border: 1px solid var(--border);
    border-radius: 10px; color: var(--text); font-size: 15px;
    outline: none; font-family: inherit;
  }
  .pw-form input:focus { border-color: var(--moss-color); }
  .pw-form button {
    padding: 12px 20px;
    background: var(--moss-color); color: #000;
    border: none; border-radius: 10px;
    font-weight: 700; cursor: pointer; font-size: 14px;
    font-family: inherit;
  }
  .pw-error { color: #ef4444; font-size: 13px; margin-top: 12px; min-height: 18px; }

  /* Main Layout */
  #app { display: none; flex-direction: column; height: 100%; height: 100dvh; }
  #app.active { display: flex; }

  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 16px;
    background: var(--bg-surface);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .header-title { font-size: 16px; font-weight: 700; color: var(--moss-color); }
  .header-title span { opacity: 0.6; font-weight: 400; }
  .conn-status { display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--text-muted); }
  .conn-dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; transition: background 0.3s; }
  .conn-dot.connected { background: var(--moss-color); }
  .conn-dot.connecting { background: var(--wren-color); animation: pulse 1s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 2px;
    flex: 1;
    min-height: 0;
    background: var(--border);
  }

  /* Panel */
  .panel {
    display: flex; flex-direction: column;
    background: var(--bg-panel);
    min-height: 0;
  }
  .panel-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 6px 12px;
    font-size: 13px; font-weight: 700;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    user-select: none;
  }
  .panel-header .agent-name { display: flex; align-items: center; gap: 6px; }
  .panel-header .agent-emoji { font-size: 16px; }
  
  /* Status badge - clickable to toggle controls */
  .panel-header .status-badge {
    font-size: 10px; font-weight: 500;
    padding: 3px 8px; border-radius: 10px;
    background: rgba(255,255,255,0.05);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }
  .panel-header .status-badge:hover {
    background: rgba(255,255,255,0.1);
  }
  /* GREEN for streaming (changed from yellow) */
  .panel-header .status-badge.streaming {
    color: var(--moss-color);
    background: rgba(74,222,128,0.15);
  }
  .panel-header .status-badge.tool {
    color: var(--kit-color);
    background: rgba(244,114,182,0.1);
  }

  .panel[data-agent="moss"] .panel-header { border-top: 2px solid var(--moss-color); }
  .panel[data-agent="wren"] .panel-header { border-top: 2px solid var(--wren-color); }
  .panel[data-agent="kit"] .panel-header { border-top: 2px solid var(--kit-color); }
  .panel[data-agent="sol"] .panel-header { border-top: 2px solid var(--sol-color); }

  /* Controls bar - HIDDEN by default, toggled by clicking status badge */
  .controls-bar {
    padding: 6px 8px;
    border-bottom: 1px solid var(--border);
    background: var(--bg-surface);
    display: none; /* hidden by default */
    flex-wrap: wrap;
    gap: 4px;
    flex-shrink: 0;
    align-items: center;
  }
  .controls-bar.visible { display: flex; }
  
  .filter-btn {
    padding: 2px 6px;
    font-size: 10px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  .filter-btn:hover { background: var(--bg-input); }
  .filter-btn.active { 
    background: var(--moss-color); 
    color: #000; 
    border-color: var(--moss-color);
    font-weight: 600;
  }
  
  /* Session selector */
  .session-select {
    padding: 2px 4px;
    font-size: 10px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-muted);
    font-family: inherit;
    cursor: pointer;
    max-width: 120px;
    margin-left: auto;
  }
  .session-select:focus { border-color: var(--moss-color); outline: none; }

  /* Messages area */
  .messages {
    flex: 1; overflow-y: auto; overflow-x: hidden;
    padding: 8px;
    display: flex; flex-direction: column;
    gap: 6px;
    min-height: 0;
  }

  /* Message styling with smooth transitions */
  .msg {
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 13px;
    line-height: 1.55;
    word-break: break-word;
    max-width: 100%;
    transition: opacity 0.15s ease;
    animation: fadeIn 0.2s ease;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .msg .role {
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 3px;
    display: block;
  }
  .msg.user { background: rgba(255,255,255,0.04); }
  .msg.user .role { color: var(--user-color); }
  .msg.assistant { background: rgba(255,255,255,0.02); }
  .msg.assistant .role { opacity: 0.8; }
  .msg.system { 
    background: rgba(255,255,255,0.02); 
    border-left: 2px solid var(--system-color); 
    padding-left: 10px;
    font-size: 12px;
  }
  .msg.system .role { color: var(--system-color); font-size: 9px; }
  
  /* Streaming message - green accent */
  .msg.streaming { 
    border-left: 2px solid var(--moss-color); 
    padding-left: 10px;
  }
  
  /* Typing indicator inline */
  .msg.typing {
    background: transparent;
    padding: 4px 10px;
  }
  .typing-indicator {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    color: var(--text-dim);
    font-size: 12px;
    font-style: italic;
  }
  .typing-dots {
    display: inline-flex;
    gap: 2px;
  }
  .typing-dots span {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: var(--moss-color);
    animation: typingBounce 1.4s ease-in-out infinite;
  }
  .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
  .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes typingBounce {
    0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
    30% { transform: translateY(-4px); opacity: 1; }
  }

  .msg.tool-call {
    font-size: 11px;
    color: var(--text-dim);
    background: rgba(255,255,255,0.02);
    font-style: italic;
    padding: 3px 8px;
  }

  .panel[data-agent="moss"] .msg.assistant .role { color: var(--moss-color); }
  .panel[data-agent="wren"] .msg.assistant .role { color: var(--wren-color); }
  .panel[data-agent="kit"] .msg.assistant .role { color: var(--kit-color); }
  .panel[data-agent="sol"] .msg.assistant .role { color: var(--sol-color); }
  
  .panel[data-agent="moss"] .msg.streaming { border-color: var(--moss-color); }
  .panel[data-agent="wren"] .msg.streaming { border-color: var(--wren-color); }
  .panel[data-agent="kit"] .msg.streaming { border-color: var(--kit-color); }
  .panel[data-agent="sol"] .msg.streaming { border-color: var(--sol-color); }

  /* Markdown content - works during streaming too */
  .msg .md-content {
    line-height: 1.6;
  }
  .msg .md-content h1, .msg .md-content h2, .msg .md-content h3 {
    margin: 8px 0 4px; font-size: 13px; color: var(--text); font-weight: 700;
  }
  .msg .md-content h1 { font-size: 15px; }
  .msg .md-content h2 { font-size: 14px; }
  .msg .md-content p { margin: 3px 0; }
  .msg .md-content ul, .msg .md-content ol { margin: 3px 0; padding-left: 20px; }
  .msg .md-content li { margin: 2px 0; }
  .msg .md-content code {
    background: rgba(255,255,255,0.08); padding: 1px 5px; border-radius: 4px;
    font-size: 12px; font-family: inherit;
  }
  .msg .md-content pre {
    background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;
    overflow-x: auto; margin: 6px 0; font-size: 12px;
  }
  .msg .md-content pre code { background: none; padding: 0; }
  .msg .md-content blockquote {
    border-left: 2px solid var(--text-dim); padding-left: 10px;
    color: var(--text-muted); margin: 6px 0; font-style: italic;
  }
  .msg .md-content strong { color: var(--text); }
  .msg .md-content em { opacity: 0.9; }
  .msg .md-content a { color: var(--moss-color); text-decoration: none; }
  .msg .md-content a:hover { text-decoration: underline; }
  .msg .md-content hr { border: none; border-top: 1px solid var(--border); margin: 8px 0; }
  .msg .md-content table { border-collapse: collapse; margin: 6px 0; font-size: 12px; }
  .msg .md-content th, .msg .md-content td { border: 1px solid var(--border); padding: 4px 8px; }
  .msg .md-content th { background: var(--bg-surface); }

  /* Input */
  .panel-input {
    display: flex; gap: 4px;
    padding: 6px 8px;
    border-top: 1px solid var(--border);
    flex-shrink: 0;
    background: var(--bg-surface);
  }
  .panel-input input {
    flex: 1; padding: 8px 10px;
    background: var(--bg-input); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text);
    font-size: 13px; outline: none;
    font-family: inherit;
    transition: border-color 0.15s;
  }
  .panel-input input:focus { border-color: rgba(255,255,255,0.25); }
  .panel-input button {
    padding: 8px 14px;
    border: none; border-radius: 8px;
    font-weight: 700; cursor: pointer;
    font-size: 13px; font-family: inherit;
    color: #000;
    transition: opacity 0.15s;
  }
  .panel[data-agent="moss"] .panel-input button { background: var(--moss-color); }
  .panel[data-agent="wren"] .panel-input button { background: var(--wren-color); }
  .panel[data-agent="kit"] .panel-input button { background: var(--kit-color); }
  .panel[data-agent="sol"] .panel-input button { background: var(--sol-color); }
  .panel-input button:hover { opacity: 0.85; }

  @media (max-width: 768px) {
    .grid { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr 1fr 1fr; }
    .panel-header { padding: 4px 10px; }
    .messages { padding: 4px; }
    .msg { font-size: 12px; }
  }
</style>
</head>
<body>

<div id="password-screen">
  <div class="pw-card">
    <h1>ðŸŒ²</h1>
    <div class="subtitle">QUARTET VIEWER</div>
    <div class="pw-form">
      <input type="password" id="pw-input" placeholder="passphrase" autocomplete="off" autofocus>
      <button onclick="tryLogin()">â†’</button>
    </div>
    <div class="pw-error" id="pw-error"></div>
  </div>
</div>

<div id="app">
  <div class="header">
    <div class="header-title">ðŸŒ² Quartet <span>viewer</span></div>
    <div class="conn-status">
      <button onclick="refreshHistories()" style="background:none;border:1px solid var(--border);color:var(--text-muted);border-radius:6px;padding:2px 8px;cursor:pointer;font-size:11px;font-family:inherit;margin-right:8px;">â†»</button>
      <div class="conn-dot" id="conn-dot"></div>
      <span id="conn-text">disconnected</span>
    </div>
  </div>
  <div class="grid" id="grid"></div>
</div>

<script>
// Markdown config
if (typeof marked !== 'undefined') {
  marked.setOptions({ breaks: true, gfm: true, headerIds: false, mangle: false });
}

const GATEWAY_URL = 'ws://localhost:18789/';
const GATEWAY_TOKEN = '775969809e41d4bd735bf3bb4839acd1b7be21a406411780';
const PASSWORD = 'grove2026';

const AGENTS = {
  moss: { emoji: 'ðŸŒ±', color: 'moss', sessionKey: 'main', altKeys: ['agent:main:main', 'agent:main:slack:channel:c0ac6trepe2'] },
  wren: { emoji: 'ðŸª¶', color: 'wren', sessionKey: 'agent:wren:main', altKeys: ['wren', 'agent:wren:slack:channel:c0ac6trepe2'] },
  kit:  { emoji: 'ðŸ§¶', color: 'kit',  sessionKey: 'agent:kit:main',  altKeys: ['kit', 'agent:kit:slack:channel:c0ac6trepe2'] },
  sol:  { emoji: 'â˜€ï¸', color: 'sol',  sessionKey: 'agent:sol:main',  altKeys: ['sol', 'agent:sol:slack:channel:c0ac6trepe2'] },
};

// State
let ws = null;
let connected = false;
let reqCounter = 0;
const activeSessionKeys = { moss: 'main', wren: 'agent:wren:main', kit: 'agent:kit:main', sol: 'agent:sol:main' };
const sessionToAgent = {};
const agentFilters = {};
const agentState = {};
const discoveredSessions = {}; // agentName -> [{key, label}, ...]
const pendingHistoryReqs = {};
const pendingSendReqs = {};

// Build session lookup
for (const [name, cfg] of Object.entries(AGENTS)) {
  sessionToAgent[cfg.sessionKey] = name;
  for (const alt of cfg.altKeys) sessionToAgent[alt] = name;
  agentFilters[name] = { systemMessages: true, toolCalls: false, crossAgentChats: true };
  agentState[name] = { runs: {}, typingEl: null };
}
sessionToAgent['main'] = 'moss';
sessionToAgent['agent:main:main'] = 'moss';

// Build panels dynamically
function buildPanels() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  
  for (const [name, cfg] of Object.entries(AGENTS)) {
    const panel = document.createElement('div');
    panel.className = 'panel';
    panel.dataset.agent = name;
    panel.innerHTML = `
      <div class="panel-header">
        <div class="agent-name"><span class="agent-emoji">${cfg.emoji}</span> ${name.charAt(0).toUpperCase() + name.slice(1)}</div>
        <div class="status-badge" id="status-${name}" onclick="toggleControls('${name}')">idle</div>
      </div>
      <div class="controls-bar" id="controls-${name}">
        <button class="filter-btn active" data-filter="systemMessages" onclick="toggleFilter('${name}', 'systemMessages')">âš™ System</button>
        <button class="filter-btn" data-filter="toolCalls" onclick="toggleFilter('${name}', 'toolCalls')">âš¡ Tools</button>
        <button class="filter-btn active" data-filter="crossAgentChats" onclick="toggleFilter('${name}', 'crossAgentChats')">ðŸ’¬ Cross</button>
        <select class="session-select" id="session-${name}" onchange="switchSession('${name}', this.value)">
          <option value="${cfg.sessionKey}">main</option>
        </select>
      </div>
      <div class="messages" id="messages-${name}"></div>
      <div class="panel-input">
        <input type="text" id="input-${name}" placeholder="Talk to ${name.charAt(0).toUpperCase() + name.slice(1)}â€¦" autocomplete="off">
        <button onclick="sendMessage('${name}')" id="btn-${name}">â†‘</button>
      </div>
    `;
    grid.appendChild(panel);
    
    // Enter key handler
    document.getElementById(`input-${name}`).addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(name); }
    });
  }
}

// Toggle controls bar visibility
function toggleControls(agentName) {
  const bar = document.getElementById(`controls-${agentName}`);
  bar.classList.toggle('visible');
}

// Session switching
function switchSession(agentName, sessionKey) {
  activeSessionKeys[agentName] = sessionKey;
  agentState[agentName].runs = {};
  fetchHistory(agentName);
}

// Populate session dropdown
function populateSessions(agentName, sessions) {
  const select = document.getElementById(`session-${agentName}`);
  if (!select) return;
  
  const current = activeSessionKeys[agentName];
  select.innerHTML = '';
  
  const seen = new Set();
  const addOpt = (key, label) => {
    if (seen.has(key)) return;
    seen.add(key);
    const opt = document.createElement('option');
    opt.value = key;
    opt.textContent = label || formatSessionKey(key);
    opt.selected = key === current;
    select.appendChild(opt);
  };
  
  // Add primary + alts
  const cfg = AGENTS[agentName];
  addOpt(cfg.sessionKey, 'main');
  for (const alt of cfg.altKeys) addOpt(alt);
  
  // Add discovered
  for (const s of sessions) addOpt(s.key, s.label);
}

function formatSessionKey(key) {
  const k = key.toLowerCase();
  if (k === 'main' || k.endsWith(':main')) return 'ðŸ’¬ direct';
  if (k.includes('slack:channel:')) {
    if (k.includes(':thread:')) return 'ðŸ§µ thread';
    return 'ðŸ”· slack';
  }
  if (k.includes('cron:')) return 'â° cron';
  return key.split(':').pop().substring(0, 12);
}

// Password
const pwInput = document.getElementById('pw-input');
pwInput.addEventListener('keydown', e => { if (e.key === 'Enter') tryLogin(); });

function tryLogin() {
  if (pwInput.value.trim() === PASSWORD) {
    document.getElementById('password-screen').classList.add('hidden');
    document.getElementById('app').classList.add('active');
    buildPanels();
    connectGateway();
  } else {
    document.getElementById('pw-error').textContent = 'Wrong passphrase';
    pwInput.value = '';
  }
}

// Gateway connection
function setConnStatus(state) {
  document.getElementById('conn-dot').className = 'conn-dot ' + state;
  document.getElementById('conn-text').textContent = state;
}

function connectGateway() {
  if (ws) try { ws.close(); } catch(e) {}
  setConnStatus('connecting');
  
  ws = new WebSocket(GATEWAY_URL);
  let gotChallenge = false, authenticated = false;

  ws.onmessage = (event) => {
    let data;
    try { data = JSON.parse(event.data); } catch(e) { return; }

    if (!gotChallenge && data.type === 'event' && data.event === 'connect.challenge') {
      gotChallenge = true;
      ws.send(JSON.stringify({
        type: 'req', id: 'auth-' + (++reqCounter), method: 'connect',
        params: {
          minProtocol: 3, maxProtocol: 3,
          client: { id: 'webchat', version: 'quartet-v2', platform: navigator.platform || 'web', mode: 'webchat' },
          auth: { token: GATEWAY_TOKEN }
        }
      }));
      return;
    }

    if (!authenticated && data.type === 'res' && data.id?.startsWith('auth-')) {
      if (data.ok) {
        authenticated = true;
        connected = true;
        setConnStatus('connected');
        discoverAllSessions();
        fetchAllHistories();
      } else {
        setConnStatus('disconnected');
      }
      return;
    }
    if (!authenticated) return;

    if (data.type === 'event') handleEvent(data);
    else if (data.type === 'res') handleResponse(data);
  };

  ws.onclose = () => {
    connected = false;
    setConnStatus('disconnected');
    setTimeout(connectGateway, 3000);
  };
  ws.onerror = () => {};
}

// Discover sessions for all agents
async function discoverAllSessions() {
  for (const name of Object.keys(AGENTS)) {
    try {
      const resp = await fetch(`/api/sessions/${name === 'moss' ? 'main' : name}`);
      if (resp.ok) {
        const data = await resp.json();
        if (data.ok && Array.isArray(data.sessions)) {
          discoveredSessions[name] = data.sessions.map(s => ({ key: s.key, label: formatSessionKey(s.key) }));
          populateSessions(name, discoveredSessions[name]);
        }
      }
    } catch(e) {}
  }
}

function fetchAllHistories() {
  for (const name of Object.keys(AGENTS)) fetchHistory(name);
}

function fetchHistory(agentName) {
  const sessionKey = activeSessionKeys[agentName];
  const reqId = 'hist-' + agentName + '-' + (++reqCounter);
  pendingHistoryReqs[reqId] = agentName;
  ws.send(JSON.stringify({ type: 'req', id: reqId, method: 'chat.history', params: { sessionKey, limit: 40 } }));
}

function handleResponse(data) {
  const reqId = data.id;
  
  if (reqId && pendingHistoryReqs[reqId]) {
    const agentName = pendingHistoryReqs[reqId];
    delete pendingHistoryReqs[reqId];
    if (data.ok && data.payload) {
      const msgs = data.payload.messages || data.payload || [];
      if (Array.isArray(msgs)) renderHistory(agentName, msgs);
    }
    return;
  }
  
  if (reqId && pendingSendReqs[reqId]) {
    const agentName = pendingSendReqs[reqId];
    delete pendingSendReqs[reqId];
    if (data.ok && data.payload?.runId) {
      agentState[agentName].runs[data.payload.runId] = { buffer: '', el: null };
    }
  }
}

function renderHistory(agentName, messages) {
  const container = document.getElementById(`messages-${agentName}`);
  const as = agentState[agentName];
  if (as && Object.keys(as.runs).length > 0) return;
  
  container.innerHTML = '';
  for (const msg of messages) {
    const text = extractText(msg);
    if (!text) continue;
    appendMessage(agentName, msg.role || 'unknown', text, false);
  }
  scrollToBottom(agentName);
}

function extractText(msg) {
  if (!msg) return '';
  const c = msg.content;
  if (typeof c === 'string') return c;
  if (Array.isArray(c)) return c.map(b => typeof b === 'string' ? b : b?.text || '').join('\n');
  return msg.text || '';
}

// Event handling
function handleEvent(data) {
  if (data.event === 'chat') handleChatEvent(data.payload || {});
  else if (data.event === 'agent') handleAgentEvent(data.payload || {});
}

function isActiveSession(agentName, sessionKey) {
  const active = activeSessionKeys[agentName];
  return active && sessionKey && (sessionKey === active || sessionKey.toLowerCase() === active.toLowerCase());
}

function handleChatEvent(payload) {
  const sessionKey = payload.sessionKey || '';
  const agentName = sessionToAgent[sessionKey];
  if (!agentName || !isActiveSession(agentName, sessionKey)) return;

  const state = payload.state;
  const runId = payload.runId;
  const message = payload.message || {};
  const role = message.role || 'assistant';
  const fullText = extractText(message);

  if (role === 'user') {
    if (state === 'final' || state === 'delta') {
      appendMessage(agentName, 'user', fullText, false);
      scrollToBottom(agentName);
    }
    return;
  }

  const as = agentState[agentName];

  if (state === 'delta') {
    if (!runId) return;
    if (!as.runs[runId]) as.runs[runId] = { buffer: '', el: null };
    const run = as.runs[runId];
    
    // Remove typing indicator when first content arrives
    removeTypingIndicator(agentName);
    
    if (fullText.length > run.buffer.length) {
      run.buffer = fullText;
      if (!run.el) {
        run.el = appendMessage(agentName, 'assistant', fullText, true);
      } else {
        // LIVE MARKDOWN: render markdown while streaming
        updateStreamingMessage(agentName, run.el, fullText);
      }
      scrollToBottom(agentName);
      setAgentStatus(agentName, 'streaming');
    }
  }
  else if (state === 'final') {
    removeTypingIndicator(agentName);
    if (runId && as.runs[runId]) {
      const run = as.runs[runId];
      if (fullText) run.buffer = fullText;
      if (run.el) {
        finalizeMessage(agentName, run.el, run.buffer);
      } else if (run.buffer) {
        appendMessage(agentName, 'assistant', run.buffer, false);
      }
      delete as.runs[runId];
    } else if (fullText) {
      appendMessage(agentName, 'assistant', fullText, false);
    }
    scrollToBottom(agentName);
    if (Object.keys(as.runs).length === 0) setAgentStatus(agentName, 'idle');
  }
  else if (state === 'aborted' || state === 'error') {
    removeTypingIndicator(agentName);
    if (runId && as.runs[runId]) {
      const run = as.runs[runId];
      if (run.el) finalizeMessage(agentName, run.el, run.buffer || '[aborted]');
      delete as.runs[runId];
    }
    if (Object.keys(as.runs).length === 0) setAgentStatus(agentName, 'idle');
  }
}

function handleAgentEvent(payload) {
  const sessionKey = payload.sessionKey || '';
  const agentName = sessionToAgent[sessionKey];
  if (!agentName || !isActiveSession(agentName, sessionKey)) return;

  if (payload.type === 'tool_use') {
    setAgentStatus(agentName, 'tool', payload.name || 'tool');
    if (agentFilters[agentName].toolCalls) {
      appendToolCall(agentName, payload.name || 'tool');
      scrollToBottom(agentName);
    }
  }
  else if (payload.type === 'thinking' || payload.type === 'start') {
    // Show typing indicator
    showTypingIndicator(agentName);
    setAgentStatus(agentName, 'streaming');
  }
}

// Typing indicator
function showTypingIndicator(agentName) {
  const as = agentState[agentName];
  if (as.typingEl) return;
  
  const container = document.getElementById(`messages-${agentName}`);
  const cfg = AGENTS[agentName];
  
  const div = document.createElement('div');
  div.className = 'msg typing';
  div.innerHTML = `
    <span class="role" style="color:var(--${cfg.color}-color)">${cfg.emoji} ${agentName}</span>
    <span class="typing-indicator">
      <span class="typing-dots"><span></span><span></span><span></span></span>
      thinking...
    </span>
  `;
  container.appendChild(div);
  as.typingEl = div;
  scrollToBottom(agentName);
}

function removeTypingIndicator(agentName) {
  const as = agentState[agentName];
  if (as.typingEl) {
    as.typingEl.remove();
    as.typingEl = null;
  }
}

// Message rendering
// Internal OpenClaw messages that should ALWAYS be hidden
const INTERNAL_MESSAGE_PATTERNS = [
  /^NO_REPLY$/,
  /^HEARTBEAT_OK$/,
  /^ANNOUNCE_SKIP$/,
  /^Agent-to-agent announce/i,
  /^Announce skipped/i,
  /^\[Announcement from/i,
  /^Cross-agent session/i,
  /^\s*$/,  // Empty/whitespace-only messages
];

// System messages (cron, heartbeat, etc) - toggleable via filter
const SYSTEM_MESSAGE_PATTERNS = [
  /^System: \[/,           // Cron/system injections like "System: [2026-02-05] Cron:"
  /^Read HEARTBEAT\.md/,   // Heartbeat prompt
];

// Tool-related content patterns
const TOOL_MESSAGE_PATTERNS = [
  /^<function_calls>/,
  /^<function_results>/,
  /"type":\s*"toolCall"/,
  /"type":\s*"toolResult"/,
];

function isInternalMessage(text) {
  if (!text || typeof text !== 'string') return false;
  const trimmed = text.trim();
  return INTERNAL_MESSAGE_PATTERNS.some(pattern => pattern.test(trimmed));
}

function isSystemMessage(text) {
  if (!text || typeof text !== 'string') return false;
  return SYSTEM_MESSAGE_PATTERNS.some(pattern => pattern.test(text));
}

function isToolMessage(text) {
  if (!text || typeof text !== 'string') return false;
  return TOOL_MESSAGE_PATTERNS.some(pattern => pattern.test(text));
}

function appendMessage(agentName, role, text, streaming) {
  const container = document.getElementById(`messages-${agentName}`);
  if (!container) return null;
  
  // Always filter internal control messages
  if (isInternalMessage(text)) return null;
  
  // Filter system messages if disabled
  if (isSystemMessage(text) && !agentFilters[agentName].systemMessages) return null;
  
  // Filter tool results by role
  if (role === 'toolResult' && !agentFilters[agentName].toolCalls) return null;
  
  // Filter tool-related content patterns if disabled  
  if (isToolMessage(text) && !agentFilters[agentName].toolCalls) return null;

  const cfg = AGENTS[agentName];
  const div = document.createElement('div');
  div.className = `msg ${role}${streaming ? ' streaming' : ''}`;

  const roleLabel = document.createElement('span');
  roleLabel.className = 'role';
  if (role === 'assistant') {
    roleLabel.textContent = `${cfg.emoji} ${agentName}`;
    roleLabel.style.color = `var(--${cfg.color}-color)`;
  } else if (role === 'user') {
    roleLabel.textContent = 'ðŸŒ™ recxa';
  } else if (role === 'toolResult') {
    roleLabel.textContent = 'âš¡ tool';
  } else {
    roleLabel.textContent = 'âš™ system';
  }
  div.appendChild(roleLabel);

  const textSpan = document.createElement('span');
  textSpan.className = 'text-content md-content';
  // Always render markdown (even while streaming for smoother experience)
  textSpan.innerHTML = renderMarkdown(text);
  div.appendChild(textSpan);

  container.appendChild(div);
  while (container.children.length > 100) container.removeChild(container.firstChild);
  
  return div;
}

function updateStreamingMessage(agentName, el, text) {
  if (!el) return;
  const textSpan = el.querySelector('.text-content');
  if (textSpan) {
    // Live markdown rendering while streaming
    textSpan.innerHTML = renderMarkdown(text);
  }
}

function finalizeMessage(agentName, el, text) {
  if (!el) return;
  el.classList.remove('streaming');
  const textSpan = el.querySelector('.text-content');
  if (textSpan) textSpan.innerHTML = renderMarkdown(text);
}

function renderMarkdown(text) {
  if (!text) return '';
  if (typeof marked !== 'undefined') {
    try {
      return marked.parse(text, { breaks: true, gfm: true });
    } catch(e) {
      return escapeHtml(text).replace(/\n/g, '<br>');
    }
  }
  return escapeHtml(text).replace(/\n/g, '<br>');
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function appendToolCall(agentName, toolName) {
  const container = document.getElementById(`messages-${agentName}`);
  const div = document.createElement('div');
  div.className = 'msg tool-call';
  div.innerHTML = `<span class="role">âš¡ tool</span><span class="text-content">${escapeHtml(toolName)}</span>`;
  container.appendChild(div);
}

function scrollToBottom(agentName) {
  const container = document.getElementById(`messages-${agentName}`);
  requestAnimationFrame(() => { container.scrollTop = container.scrollHeight; });
}

function setAgentStatus(agentName, status, detail) {
  const badge = document.getElementById(`status-${agentName}`);
  if (!badge) return;
  badge.className = 'status-badge' + (status === 'streaming' ? ' streaming' : status === 'tool' ? ' tool' : '');
  badge.textContent = status === 'streaming' ? 'â— streaming' : status === 'tool' ? `âš¡ ${detail}` : 'idle';
}

// Filters
function toggleFilter(agentName, filterName) {
  agentFilters[agentName][filterName] = !agentFilters[agentName][filterName];
  const panel = document.querySelector(`[data-agent="${agentName}"]`);
  panel.querySelectorAll('.filter-btn').forEach(btn => {
    btn.classList.toggle('active', agentFilters[agentName][btn.dataset.filter]);
  });
  if (Object.keys(agentState[agentName].runs).length === 0) fetchHistory(agentName);
}

// Send message
function sendMessage(agentName) {
  const input = document.getElementById(`input-${agentName}`);
  const text = input.value.trim();
  if (!text || !connected) return;
  input.value = '';

  appendMessage(agentName, 'user', text, false);
  scrollToBottom(agentName);
  showTypingIndicator(agentName);

  const sessionKey = activeSessionKeys[agentName];
  const reqId = 'send-' + agentName + '-' + (++reqCounter);
  pendingSendReqs[reqId] = agentName;

  ws.send(JSON.stringify({
    type: 'req', id: reqId, method: 'chat.send',
    params: { sessionKey, message: text, idempotencyKey: crypto.randomUUID?.() || '' + Math.random() }
  }));
  setAgentStatus(agentName, 'streaming');
}

function refreshHistories() {
  if (connected) fetchAllHistories();
}

// Keepalive
setInterval(() => { if (ws?.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: 'ping' })); }, 30000);
</script>
</body>
</html>
