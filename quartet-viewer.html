<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>üéµ quartet</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéµ</text></svg>">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
  :root {
    --bg: #080c08;
    --bg-surface: #0e150e;
    --bg-panel: #111a11;
    --bg-input: #1a241a;
    --border: #2a3a2a;
    --text: #e8e8e0;
    --text-muted: #6a7a6a;
    --text-dim: #4a5a4a;
    --moss-color: #4ade80;
    --wren-color: #f59e0b;
    --kit-color: #f472b6;
    --sol-color: #facc15;
    --user-color: #9ca3af;
    --system-color: #5a6a5a;
    --scrollbar-thumb: #2a3a2a;
    --scrollbar-track: transparent;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'JetBrains Mono', monospace;
    font-size: 14px;
    overflow: hidden;
    -webkit-text-size-adjust: 100%;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
  ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }

  /* ‚îÄ‚îÄ Password Screen ‚îÄ‚îÄ */
  #password-screen {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.97);
    display: flex; align-items: center; justify-content: center;
    z-index: 200;
    backdrop-filter: blur(12px);
  }
  #password-screen.hidden { display: none; }

  .pw-card {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 40px 32px;
    max-width: 380px; width: 90%;
    text-align: center;
  }
  .pw-card h1 { font-size: 36px; margin-bottom: 4px; color: var(--moss-color); }
  .pw-card .subtitle { color: var(--text-muted); margin-bottom: 28px; font-size: 13px; letter-spacing: 0.5px; }
  .pw-form { display: flex; gap: 8px; }
  .pw-form input {
    flex: 1; padding: 12px 16px;
    background: var(--bg-input); border: 1px solid var(--border);
    border-radius: 10px; color: var(--text); font-size: 15px;
    outline: none; font-family: inherit;
  }
  .pw-form input:focus { border-color: var(--moss-color); }
  .pw-form button {
    padding: 12px 20px;
    background: var(--moss-color); color: #000;
    border: none; border-radius: 10px;
    font-weight: 700; cursor: pointer; font-size: 14px;
    font-family: inherit;
  }
  .pw-form button:hover { opacity: 0.9; }
  .pw-error { color: #ef4444; font-size: 13px; margin-top: 12px; min-height: 18px; }

  /* ‚îÄ‚îÄ Main Layout ‚îÄ‚îÄ */
  #app { display: none; flex-direction: column; height: 100%; height: 100dvh; }
  #app.active { display: flex; }

  /* Header */
  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 16px;
    background: var(--bg-surface);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .header-title {
    font-size: 16px; font-weight: 700;
    color: var(--moss-color);
  }
  .header-title span { opacity: 0.6; font-weight: 400; }
  .conn-status {
    display: flex; align-items: center; gap: 6px;
    font-size: 12px; color: var(--text-muted);
  }
  .conn-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #ef4444;
    transition: background 0.3s;
  }
  .conn-dot.connected { background: var(--moss-color); }
  .conn-dot.connecting { background: var(--wren-color); animation: pulse 1s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  /* Grid */
  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 2px;
    flex: 1;
    min-height: 0;
    background: var(--border);
  }

  /* Panel */
  .panel {
    display: flex; flex-direction: column;
    background: var(--bg-panel);
    min-height: 0;
    position: relative;
  }
  .panel-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 6px 12px;
    font-size: 13px; font-weight: 700;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    user-select: none;
  }
  .panel-header .agent-name { display: flex; align-items: center; gap: 6px; }
  .panel-header .agent-emoji { font-size: 16px; }
  .panel-header .status-badge {
    font-size: 10px; font-weight: 400;
    padding: 2px 6px; border-radius: 8px;
    background: rgba(255,255,255,0.05);
    color: var(--text-dim);
  }
  .panel-header .status-badge.streaming {
    color: var(--wren-color);
    background: rgba(245,158,11,0.1);
    animation: pulse 1.5s infinite;
  }
  .panel-header .status-badge.tool {
    color: var(--kit-color);
    background: rgba(244,114,182,0.1);
  }

  .panel[data-agent="moss"] .panel-header { border-top: 2px solid var(--moss-color); }
  .panel[data-agent="wren"] .panel-header { border-top: 2px solid var(--wren-color); }
  .panel[data-agent="kit"] .panel-header { border-top: 2px solid var(--kit-color); }
  .panel[data-agent="sol"] .panel-header { border-top: 2px solid var(--sol-color); }

  /* Messages area */
  .messages {
    flex: 1; overflow-y: auto; overflow-x: hidden;
    padding: 8px;
    display: flex; flex-direction: column;
    gap: 4px;
    min-height: 0;
    scroll-behavior: smooth;
  }

  .msg {
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 13px;
    line-height: 1.5;
    word-break: break-word;
    white-space: pre-wrap;
    max-width: 100%;
  }
  .msg .role {
    font-weight: 700;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
    display: block;
  }
  .msg.user { background: rgba(255,255,255,0.03); }
  .msg.user .role { color: var(--user-color); }
  .msg.assistant .role { opacity: 0.7; }
  .msg.system { background: rgba(255,255,255,0.02); border-left: 2px solid var(--system-color); padding-left: 10px; }
  .msg.system .role { color: var(--system-color); font-size: 10px; }
  .msg.streaming { border-left: 2px solid; padding-left: 10px; }
  .msg.streaming::after {
    content: '‚ñä'; animation: blink 0.8s step-end infinite;
    opacity: 0.5;
  }
  @keyframes blink { 0%,100% { opacity: 0.5; } 50% { opacity: 0; } }

  .msg.tool-call {
    font-size: 11px;
    color: var(--text-dim);
    background: rgba(255,255,255,0.02);
    font-style: italic;
    padding: 2px 8px;
  }

  .panel[data-agent="moss"] .msg.assistant .role { color: var(--moss-color); }
  .panel[data-agent="wren"] .msg.assistant .role { color: var(--wren-color); }
  .panel[data-agent="kit"] .msg.assistant .role { color: var(--kit-color); }
  .panel[data-agent="sol"] .msg.assistant .role { color: var(--sol-color); }

  .panel[data-agent="moss"] .msg.streaming { border-color: var(--moss-color); }
  .panel[data-agent="wren"] .msg.streaming { border-color: var(--wren-color); }
  .panel[data-agent="kit"] .msg.streaming { border-color: var(--kit-color); }
  .panel[data-agent="sol"] .msg.streaming { border-color: var(--sol-color); }

  /* Filter bar */
  .filter-bar {
    padding: 6px 8px;
    border-bottom: 1px solid var(--border);
    background: var(--bg-deep);
    display: flex;
    gap: 4px;
    flex-shrink: 0;
  }
  .filter-btn {
    padding: 2px 6px;
    font-size: 10px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }
  .filter-btn:hover { background: var(--bg-input); }
  .filter-btn.active { 
    background: var(--moss-color); 
    color: #000; 
    border-color: var(--moss-color);
    font-weight: 600;
  }
  .filter-btn.active:hover { opacity: 0.9; }

  /* Received messages */
  .msg.received {
    background: rgba(245,158,11,0.08);
    border-left: 2px solid var(--wren-color);
    padding-left: 10px;
  }
  .msg.received .role { color: var(--wren-color); }
  .msg.received .msg-content { font-style: italic; opacity: 0.9; }

  /* Input */
  .panel-input {
    display: flex; gap: 4px;
    padding: 6px 8px;
    border-top: 1px solid var(--border);
    flex-shrink: 0;
    background: var(--bg-surface);
  }
  .panel-input input {
    flex: 1; padding: 8px 10px;
    background: var(--bg-input); border: 1px solid var(--border);
    border-radius: 8px; color: var(--text);
    font-size: 13px; outline: none;
    font-family: inherit;
  }
  .panel-input input:focus { border-color: rgba(255,255,255,0.2); }
  .panel-input button {
    padding: 8px 12px;
    border: none; border-radius: 8px;
    font-weight: 700; cursor: pointer;
    font-size: 12px; font-family: inherit;
    color: #000;
  }
  .panel[data-agent="moss"] .panel-input button { background: var(--moss-color); }
  .panel[data-agent="wren"] .panel-input button { background: var(--wren-color); }
  .panel[data-agent="kit"] .panel-input button { background: var(--kit-color); }
  .panel[data-agent="sol"] .panel-input button { background: var(--sol-color); }
  .panel-input button:hover { opacity: 0.85; }
  .panel-input button:disabled { opacity: 0.4; cursor: default; }

  /* Empty state */
  .empty-state {
    flex: 1; display: flex;
    align-items: center; justify-content: center;
    color: var(--text-dim); font-size: 12px;
    font-style: italic;
  }

  /* Markdown styles */
  .msg .md-content h1, .msg .md-content h2, .msg .md-content h3 {
    margin: 6px 0 3px; font-size: 13px; color: var(--text);
  }
  .msg .md-content h1 { font-size: 15px; }
  .msg .md-content h2 { font-size: 14px; }
  .msg .md-content p { margin: 2px 0; }
  .msg .md-content ul, .msg .md-content ol { margin: 2px 0; padding-left: 18px; }
  .msg .md-content li { margin: 1px 0; }
  .msg .md-content code {
    background: rgba(255,255,255,0.08); padding: 1px 4px; border-radius: 3px;
    font-size: 12px; font-family: inherit;
  }
  .msg .md-content pre {
    background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px;
    overflow-x: auto; margin: 4px 0; font-size: 12px;
  }
  .msg .md-content pre code { background: none; padding: 0; }
  .msg .md-content blockquote {
    border-left: 2px solid var(--text-dim); padding-left: 8px;
    color: var(--text-muted); margin: 4px 0;
  }
  .msg .md-content strong { color: var(--text); }
  .msg .md-content a { color: var(--moss-color); text-decoration: none; }
  .msg .md-content a:hover { text-decoration: underline; }
  .msg .md-content hr { border: none; border-top: 1px solid var(--border); margin: 6px 0; }

  /* Mobile responsive */
  @media (max-width: 768px) {
    .grid {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr 1fr 1fr;
    }
    .panel-header { padding: 4px 10px; }
    .messages { padding: 4px; }
    .msg { font-size: 12px; }
  }
</style>
</head>
<body>

<!-- Password Gate -->
<div id="password-screen">
  <div class="pw-card">
    <h1>üå≤</h1>
    <div class="subtitle">QUARTET VIEWER</div>
    <div class="pw-form">
      <input type="password" id="pw-input" placeholder="passphrase" autocomplete="off" autofocus>
      <button onclick="tryLogin()">‚Üí</button>
    </div>
    <div class="pw-error" id="pw-error"></div>
  </div>
</div>

<!-- Main App -->
<div id="app">
  <div class="header">
    <div class="header-title">üå≤ Quartet <span>viewer</span></div>
    <div class="conn-status">
      <button onclick="refreshHistories()" style="background:none;border:1px solid var(--border);color:var(--text-muted);border-radius:6px;padding:2px 8px;cursor:pointer;font-size:11px;font-family:inherit;margin-right:8px;">‚Üª refresh</button>
      <div class="conn-dot" id="conn-dot"></div>
      <span id="conn-text">disconnected</span>
    </div>
  </div>
  <div class="grid">
    <div class="panel" data-agent="moss">
      <div class="panel-header">
        <div class="agent-name"><span class="agent-emoji">üå±</span> Moss</div>
        <div class="status-badge" id="status-moss">idle</div>
      </div>
      <div class="filter-bar">
        <button class="filter-btn active" data-filter="systemMessages" onclick="toggleFilter('moss', 'systemMessages')">
          ‚öô System
        </button>
        <button class="filter-btn" data-filter="toolCalls" onclick="toggleFilter('moss', 'toolCalls')">
          ‚ö° Tools
        </button>
        <button class="filter-btn active" data-filter="crossAgentChats" onclick="toggleFilter('moss', 'crossAgentChats')">
          üí¨ Cross-Agent
        </button>
      </div>
      <div class="messages" id="messages-moss"></div>
      <div class="panel-input">
        <input type="text" id="input-moss" placeholder="Talk to Moss‚Ä¶" autocomplete="off">
        <button onclick="sendMessage('moss')" id="btn-moss">‚Üë</button>
      </div>
    </div>
    <div class="panel" data-agent="wren">
      <div class="panel-header">
        <div class="agent-name"><span class="agent-emoji">ü™∂</span> Wren</div>
        <div class="status-badge" id="status-wren">idle</div>
      </div>
      <div class="filter-bar">
        <button class="filter-btn active" data-filter="systemMessages" onclick="toggleFilter('wren', 'systemMessages')">
          ‚öô System
        </button>
        <button class="filter-btn" data-filter="toolCalls" onclick="toggleFilter('wren', 'toolCalls')">
          ‚ö° Tools
        </button>
        <button class="filter-btn active" data-filter="crossAgentChats" onclick="toggleFilter('wren', 'crossAgentChats')">
          üí¨ Cross-Agent
        </button>
      </div>
      <div class="messages" id="messages-wren"></div>
      <div class="panel-input">
        <input type="text" id="input-wren" placeholder="Talk to Wren‚Ä¶" autocomplete="off">
        <button onclick="sendMessage('wren')" id="btn-wren">‚Üë</button>
      </div>
    </div>
    <div class="panel" data-agent="kit">
      <div class="panel-header">
        <div class="agent-name"><span class="agent-emoji">üß∂</span> Kit</div>
        <div class="status-badge" id="status-kit">idle</div>
      </div>
      <div class="filter-bar">
        <button class="filter-btn active" data-filter="systemMessages" onclick="toggleFilter('kit', 'systemMessages')">
          ‚öô System
        </button>
        <button class="filter-btn" data-filter="toolCalls" onclick="toggleFilter('kit', 'toolCalls')">
          ‚ö° Tools
        </button>
        <button class="filter-btn active" data-filter="crossAgentChats" onclick="toggleFilter('kit', 'crossAgentChats')">
          üí¨ Cross-Agent
        </button>
      </div>
      <div class="messages" id="messages-kit"></div>
      <div class="panel-input">
        <input type="text" id="input-kit" placeholder="Talk to Kit‚Ä¶" autocomplete="off">
        <button onclick="sendMessage('kit')" id="btn-kit">‚Üë</button>
      </div>
    </div>
    <div class="panel" data-agent="sol">
      <div class="panel-header">
        <div class="agent-name"><span class="agent-emoji">‚òÄÔ∏è</span> Sol</div>
        <div class="status-badge" id="status-sol">idle</div>
      </div>
      <div class="filter-bar">
        <button class="filter-btn active" data-filter="systemMessages" onclick="toggleFilter('sol', 'systemMessages')">
          ‚öô System
        </button>
        <button class="filter-btn" data-filter="toolCalls" onclick="toggleFilter('sol', 'toolCalls')">
          ‚ö° Tools
        </button>
        <button class="filter-btn active" data-filter="crossAgentChats" onclick="toggleFilter('sol', 'crossAgentChats')">
          üí¨ Cross-Agent
        </button>
      </div>
      <div class="messages" id="messages-sol"></div>
      <div class="panel-input">
        <input type="text" id="input-sol" placeholder="Talk to Sol‚Ä¶" autocomplete="off">
        <button onclick="sendMessage('sol')" id="btn-sol">‚Üë</button>
      </div>
    </div>
  </div>
</div>

<script>
// ‚îÄ‚îÄ Markdown config ‚îÄ‚îÄ
if (typeof marked !== 'undefined') {
  marked.setOptions({ breaks: true, gfm: true, headerIds: false, mangle: false });
}

// ‚îÄ‚îÄ Config ‚îÄ‚îÄ
const GATEWAY_URL = 'ws://localhost:18789/';
const GATEWAY_TOKEN = '775969809e41d4bd735bf3bb4839acd1b7be21a406411780';
const PASSWORD = 'grove2026';

const AGENTS = {
  moss: { emoji: 'üå±', sessionKey: 'agent:main:slack:channel:c0ac6trepe2', altKeys: ['main', 'agent:main:main'] },
  wren: { emoji: 'ü™∂', sessionKey: 'agent:wren:main', altKeys: ['wren', 'agent:wren:slack:channel:c0ac6trepe2'] },
  kit:  { emoji: 'üß∂', sessionKey: 'agent:kit:main',  altKeys: ['kit', 'agent:kit:slack:channel:c0ac6trepe2'] },
  sol:  { emoji: '‚òÄÔ∏è', sessionKey: 'agent:sol:main',  altKeys: ['sol', 'agent:sol:slack:channel:c0ac6trepe2'] },
};

// Build session‚Üíagent lookup
const sessionToAgent = {};
for (const [name, cfg] of Object.entries(AGENTS)) {
  sessionToAgent[cfg.sessionKey] = name;
  for (const alt of cfg.altKeys) sessionToAgent[alt] = name;
}

// ‚îÄ‚îÄ State ‚îÄ‚îÄ
let ws = null;
let connected = false;
let reqCounter = 0;

// Message filters per agent
const agentFilters = {};
for (const name of Object.keys(AGENTS)) {
  agentFilters[name] = {
    systemMessages: true,
    toolCalls: false, // hidden by default
    crossAgentChats: true
  };
}

// Per-agent streaming state
const agentState = {};
for (const name of Object.keys(AGENTS)) {
  agentState[name] = {
    runs: {},       // runId -> { buffer, el }
    streaming: false,
  };
}

// ‚îÄ‚îÄ Password ‚îÄ‚îÄ
const pwInput = document.getElementById('pw-input');
pwInput.addEventListener('keydown', e => { if (e.key === 'Enter') tryLogin(); });

function tryLogin() {
  const pw = pwInput.value.trim();
  if (pw === PASSWORD) {
    document.getElementById('password-screen').classList.add('hidden');
    document.getElementById('app').classList.add('active');
    
    // Initialize filter buttons
    for (const name of Object.keys(AGENTS)) {
      updateFilterButtons(name);
    }
    
    connectGateway();
  } else {
    document.getElementById('pw-error').textContent = 'Wrong passphrase';
    pwInput.value = '';
    pwInput.focus();
  }
}

// ‚îÄ‚îÄ Input handlers ‚îÄ‚îÄ
for (const name of Object.keys(AGENTS)) {
  const input = document.getElementById(`input-${name}`);
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage(name);
    }
  });
}

// ‚îÄ‚îÄ Gateway Connection ‚îÄ‚îÄ
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0;
    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
  });
}

function setConnStatus(state) {
  const dot = document.getElementById('conn-dot');
  const text = document.getElementById('conn-text');
  dot.className = 'conn-dot ' + state;
  text.textContent = state;
}

function connectGateway() {
  if (ws) { try { ws.close(); } catch(e) {} }
  setConnStatus('connecting');

  // Determine WS URL ‚Äî if page loaded over HTTPS, we can't connect to ws://localhost
  // In that case, use the server's WebSocket proxy
  let wsUrl = GATEWAY_URL;
  if (location.protocol === 'https:') {
    // Use proxy through our server
    wsUrl = `wss://${location.host}/ws-proxy`;
  }

  ws = new WebSocket(wsUrl);

  ws.onopen = () => {
    console.log('WS opened, waiting for challenge...');
  };

  let gotChallenge = false;
  let authenticated = false;

  ws.onmessage = (event) => {
    let data;
    try { data = JSON.parse(event.data); } catch(e) { return; }

    // Step 1: receive challenge
    if (!gotChallenge && data.type === 'event' && data.event === 'connect.challenge') {
      gotChallenge = true;
      console.log('Got challenge, sending auth...');
      ws.send(JSON.stringify({
        type: 'req',
        id: 'auth-' + (++reqCounter),
        method: 'connect',
        params: {
          minProtocol: 3,
          maxProtocol: 3,
          client: {
            id: 'webchat',
            version: 'quartet-viewer',
            platform: navigator.platform || 'web',
            mode: 'webchat',
          },
          auth: { token: GATEWAY_TOKEN }
        }
      }));
      return;
    }

    // Step 2: auth response
    if (!authenticated && data.type === 'res' && data.id && data.id.startsWith('auth-')) {
      if (data.ok) {
        authenticated = true;
        connected = true;
        setConnStatus('connected');
        console.log('Authenticated! Fetching histories...');
        fetchAllHistories();
      } else {
        console.error('Auth failed:', data.error);
        setConnStatus('disconnected');
      }
      return;
    }

    if (!authenticated) return;

    // Handle events
    if (data.type === 'event') {
      handleEvent(data);
    }
    // Handle responses (for history, send, etc.)
    else if (data.type === 'res') {
      handleResponse(data);
    }
  };

  ws.onclose = () => {
    connected = false;
    setConnStatus('disconnected');
    console.log('WS closed, reconnecting in 3s...');
    setTimeout(connectGateway, 3000);
  };

  ws.onerror = (e) => {
    console.error('WS error:', e);
  };
}

// ‚îÄ‚îÄ History ‚îÄ‚îÄ
const pendingHistoryReqs = {}; // reqId -> agentName

function fetchAllHistories() {
  for (const [name, cfg] of Object.entries(AGENTS)) {
    const reqId = 'hist-' + name + '-' + (++reqCounter);
    pendingHistoryReqs[reqId] = name;
    ws.send(JSON.stringify({
      type: 'req',
      id: reqId,
      method: 'chat.history',
      params: {
        sessionKey: cfg.sessionKey,
        limit: 30,
      }
    }));
  }
}

const pendingSendReqs = {}; // reqId -> agentName (to track run starts)

function handleResponse(data) {
  const reqId = data.id;

  // History response
  if (reqId && pendingHistoryReqs[reqId]) {
    const agentName = pendingHistoryReqs[reqId];
    delete pendingHistoryReqs[reqId];

    if (data.ok && data.payload) {
      const messages = data.payload.messages || data.payload || [];
      if (Array.isArray(messages)) {
        renderHistory(agentName, messages);
      }
    } else {
      // Try alt key
      const cfg = AGENTS[agentName];
      if (cfg && cfg.altKeys.length > 0 && !reqId.includes('alt')) {
        const altReqId = 'hist-' + agentName + '-alt-' + (++reqCounter);
        pendingHistoryReqs[altReqId] = agentName;
        ws.send(JSON.stringify({
          type: 'req',
          id: altReqId,
          method: 'chat.history',
          params: {
            sessionKey: cfg.altKeys[0],
            limit: 30,
          }
        }));
        // Update sessionToAgent with the alt key as primary for future sends
        console.log(`Primary key failed for ${agentName}, trying alt: ${cfg.altKeys[0]}`);
      } else {
        console.warn(`History failed for ${agentName}:`, data.error);
      }
    }
    return;
  }

  // Send response ‚Äî track runId
  if (reqId && pendingSendReqs[reqId]) {
    const agentName = pendingSendReqs[reqId];
    delete pendingSendReqs[reqId];

    if (data.ok && data.payload && data.payload.runId) {
      const runId = data.payload.runId;
      agentState[agentName].runs[runId] = { buffer: '', el: null };
      console.log(`Run ${runId} started for ${agentName}`);
    } else if (!data.ok) {
      console.warn(`Send failed for ${agentName}:`, data.error);
      // Try alt key if primary failed
      // (handled separately if needed)
    }
    return;
  }
}

function renderHistory(agentName, messages) {
  const container = document.getElementById(`messages-${agentName}`);
  
  // Don't refresh if there's an active stream ‚Äî it would clobber it
  const as = agentState[agentName];
  if (as && Object.keys(as.runs).length > 0) return;
  
  // Track message count to avoid unnecessary re-renders
  const msgCount = messages.filter(m => extractText(m)).length;
  const prevCount = container.dataset.msgCount;
  if (prevCount && parseInt(prevCount) === msgCount) return; // no new messages
  container.dataset.msgCount = msgCount;
  
  container.innerHTML = '';

  for (const msg of messages) {
    const role = msg.role || 'unknown';
    const content = extractText(msg);
    if (!content) continue;

    // Detect inter-agent messages ‚Äî user messages that contain agent signatures
    let senderOverride = null;
    if (role === 'user') {
      for (const [name, cfg] of Object.entries(AGENTS)) {
        if (name === agentName) continue;
        const lc = content.toLowerCase();
        if (lc.startsWith(`hey ${agentName}`) || lc.includes(`it's ${name}`) || lc.includes(`‚Äî ${name}`) || lc.includes(`- ${name}`)) {
          senderOverride = name;
          break;
        }
      }
    }

    appendMessage(agentName, role, content, false, senderOverride);
  }
  scrollToBottom(agentName);
}

function extractText(msg) {
  if (!msg) return '';
  // msg.content can be string or array of blocks
  const content = msg.content;
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) {
    const texts = [];
    for (const block of content) {
      if (typeof block === 'string') texts.push(block);
      else if (block && block.type === 'text' && block.text) texts.push(block.text);
    }
    return texts.join('\n');
  }
  // Maybe message is { text: ... }
  if (msg.text) return msg.text;
  return '';
}

// ‚îÄ‚îÄ Events ‚îÄ‚îÄ
function handleEvent(data) {
  const event = data.event;
  const payload = data.payload || {};

  if (event === 'chat') {
    handleChatEvent(payload);
  } else if (event === 'agent') {
    handleAgentEvent(payload);
  }
}

function resolveAgent(sessionKey) {
  // Direct match
  if (sessionToAgent[sessionKey]) return sessionToAgent[sessionKey];
  // Partial match ‚Äî check if sessionKey contains agent name
  const lower = (sessionKey || '').toLowerCase();
  for (const name of Object.keys(AGENTS)) {
    if (lower.includes(name)) return name;
  }
  // Default to moss for "main"
  if (lower === 'main') return 'moss';
  return null;
}

function handleChatEvent(payload) {
  const sessionKey = payload.sessionKey || '';
  const agentName = resolveAgent(sessionKey);
  if (!agentName) {
    console.log('Unknown session:', sessionKey);
    return;
  }

  const state = payload.state;
  const runId = payload.runId;
  const message = payload.message || {};
  const role = message.role || 'assistant';
  const fullText = extractText(message);

  if (role === 'user') {
    // User message ‚Äî just display it
    if (state === 'final' || state === 'delta') {
      appendMessage(agentName, 'user', fullText, false);
      scrollToBottom(agentName);
    }
    return;
  }

  // Assistant messages ‚Äî handle streaming
  const as = agentState[agentName];

  if (state === 'delta') {
    if (!runId) return;
    if (!as.runs[runId]) {
      as.runs[runId] = { buffer: '', el: null };
    }
    const run = as.runs[runId];
    const prevLen = run.buffer.length;

    if (fullText.length > prevLen) {
      run.buffer = fullText;
      if (!run.el) {
        run.el = appendMessage(agentName, 'assistant', fullText, true);
      } else {
        updateStreamingMessage(run.el, fullText);
      }
      scrollToBottom(agentName);
      setAgentStatus(agentName, 'streaming');
    }
  }
  else if (state === 'final') {
    if (runId && as.runs[runId]) {
      const run = as.runs[runId];
      if (fullText) run.buffer = fullText;
      if (run.el) {
        finalizeStreamingMessage(run.el, run.buffer);
      } else if (run.buffer) {
        appendMessage(agentName, 'assistant', run.buffer, false);
      }
      delete as.runs[runId];
    } else if (fullText) {
      appendMessage(agentName, 'assistant', fullText, false);
    }
    scrollToBottom(agentName);
    // Check if any other runs still active
    if (Object.keys(as.runs).length === 0) {
      setAgentStatus(agentName, 'idle');
    }
  }
  else if (state === 'aborted' || state === 'error') {
    if (runId && as.runs[runId]) {
      const run = as.runs[runId];
      if (run.el) {
        finalizeStreamingMessage(run.el, run.buffer || '[aborted]');
      }
      delete as.runs[runId];
    }
    if (Object.keys(as.runs).length === 0) {
      setAgentStatus(agentName, 'idle');
    }
  }
}

function handleAgentEvent(payload) {
  const sessionKey = payload.sessionKey || '';
  const agentName = resolveAgent(sessionKey);
  if (!agentName) return;

  const type = payload.type;
  if (type === 'tool_use') {
    const toolName = payload.name || 'tool';
    // Show tool indicator
    setAgentStatus(agentName, 'tool', toolName);
    appendToolCall(agentName, toolName);
    scrollToBottom(agentName);
  }
}

// ‚îÄ‚îÄ Message Filters ‚îÄ‚îÄ
function toggleFilter(agentName, filterName) {
  agentFilters[agentName][filterName] = !agentFilters[agentName][filterName];
  updateFilterButtons(agentName);
  
  // Re-render messages for this agent
  const container = document.getElementById(`messages-${agentName}`);
  const as = agentState[agentName];
  if (as && Object.keys(as.runs).length === 0) {
    // Only refresh if no active streams
    fetchHistory(agentName);
  }
}

function updateFilterButtons(agentName) {
  const panel = document.querySelector(`[data-agent="${agentName}"]`);
  if (!panel) return;
  
  const buttons = panel.querySelectorAll('.filter-btn');
  buttons.forEach(btn => {
    const filter = btn.dataset.filter;
    btn.classList.toggle('active', agentFilters[agentName][filter]);
  });
}

function fetchHistory(agentName) {
  const cfg = AGENTS[agentName];
  if (!cfg || !ws || !connected) return;
  
  const reqId = 'hist-' + agentName + '-' + (++reqCounter);
  pendingHistoryReqs[reqId] = agentName;
  ws.send(JSON.stringify({
    type: 'req',
    id: reqId,
    method: 'chat.history',
    params: {
      sessionKey: cfg.sessionKey,
      limit: 30,
    }
  }));
}

// ‚îÄ‚îÄ DOM Helpers ‚îÄ‚îÄ
function appendMessage(agentName, role, text, streaming, senderOverride) {
  const container = document.getElementById(`messages-${agentName}`);
  if (!container) return null;

  // Check filters
  if (role === 'system' && !agentFilters[agentName].systemMessages) return null;

  const div = document.createElement('div');
  div.className = `msg ${role}${streaming ? ' streaming' : ''}`;

  // If this is a received message (from another agent), style differently
  if (role === 'user' && senderOverride) {
    div.classList.add('received');
  }

  const roleLabel = document.createElement('span');
  roleLabel.className = 'role';
  // Show agent name instead of "assistant"
  if (role === 'assistant') {
    const cfg = AGENTS[agentName];
    roleLabel.textContent = cfg ? `${cfg.emoji} ${agentName}` : agentName;
  } else if (role === 'user' && senderOverride && AGENTS[senderOverride]) {
    const scfg = AGENTS[senderOverride];
    roleLabel.textContent = `${scfg.emoji} ${senderOverride}`;
    roleLabel.style.color = `var(--${senderOverride}-color)`;
  } else if (role === 'user') {
    roleLabel.textContent = 'üåô recxa';
  } else if (role === 'system') {
    roleLabel.textContent = '‚öô system';
  } else {
    roleLabel.textContent = role;
  }
  div.appendChild(roleLabel);

  const textSpan = document.createElement('span');
  textSpan.className = role === 'assistant' ? 'text-content md-content' : 'text-content';
  if (role === 'assistant' && !streaming && typeof marked !== 'undefined') {
    textSpan.innerHTML = marked.parse(text, { breaks: true, gfm: true });
  } else {
    textSpan.textContent = text;
  }
  div.appendChild(textSpan);

  container.appendChild(div);

  // Trim old messages (keep last 100)
  while (container.children.length > 100) {
    container.removeChild(container.firstChild);
  }

  return div;
}

function updateStreamingMessage(el, text) {
  if (!el) return;
  const textSpan = el.querySelector('.text-content');
  if (textSpan) textSpan.textContent = text;
}

function finalizeStreamingMessage(el, text) {
  if (!el) return;
  el.classList.remove('streaming');
  const textSpan = el.querySelector('.text-content');
  if (textSpan) {
    if (typeof marked !== 'undefined') {
      textSpan.classList.add('md-content');
      textSpan.innerHTML = marked.parse(text, { breaks: true, gfm: true });
    } else {
      textSpan.textContent = text;
    }
  }
}

function appendToolCall(agentName, toolName) {
  // Respect filter
  if (!agentFilters[agentName].toolCalls) return;
  
  const container = document.getElementById(`messages-${agentName}`);
  if (!container) return;
  
  const div = document.createElement('div');
  div.className = 'msg tool-call system';
  
  const roleLabel = document.createElement('span');
  roleLabel.className = 'role';
  roleLabel.textContent = '‚ö° tool';
  div.appendChild(roleLabel);
  
  const textSpan = document.createElement('span');
  textSpan.className = 'text-content';
  textSpan.textContent = toolName;
  div.appendChild(textSpan);
  
  container.appendChild(div);
}

function scrollToBottom(agentName) {
  const container = document.getElementById(`messages-${agentName}`);
  if (!container) return;
  requestAnimationFrame(() => {
    container.scrollTop = container.scrollHeight;
  });
}

function setAgentStatus(agentName, status, detail) {
  const badge = document.getElementById(`status-${agentName}`);
  if (!badge) return;
  badge.className = 'status-badge';
  if (status === 'streaming') {
    badge.classList.add('streaming');
    badge.textContent = '‚óè streaming';
  } else if (status === 'tool') {
    badge.classList.add('tool');
    badge.textContent = `‚ö° ${detail || 'tool'}`;
  } else {
    badge.textContent = 'idle';
  }
}

// ‚îÄ‚îÄ Send Message ‚îÄ‚îÄ
function sendMessage(agentName) {
  const input = document.getElementById(`input-${agentName}`);
  const text = input.value.trim();
  if (!text || !connected) return;

  input.value = '';

  // Show user message immediately
  appendMessage(agentName, 'user', text, false);
  scrollToBottom(agentName);

  // Determine session key ‚Äî try primary, fall back to alt
  const cfg = AGENTS[agentName];
  const sessionKey = cfg.sessionKey;

  const reqId = 'send-' + agentName + '-' + (++reqCounter);
  const idemKey = uuid();

  pendingSendReqs[reqId] = agentName;

  ws.send(JSON.stringify({
    type: 'req',
    id: reqId,
    method: 'chat.send',
    params: {
      sessionKey: sessionKey,
      message: text,
      idempotencyKey: idemKey,
    }
  }));

  setAgentStatus(agentName, 'streaming');
  console.log(`Sent to ${agentName} (${sessionKey}): ${text.substring(0, 50)}...`);
}

// ‚îÄ‚îÄ Refresh ‚îÄ‚îÄ
function refreshHistories() {
  if (connected) fetchAllHistories();
}

// ‚îÄ‚îÄ Keepalive + Auto-refresh ‚îÄ‚îÄ
setInterval(() => {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'ping' }));
  }
}, 30000);

// Auto-refresh history every 15s to catch inter-agent messages
setInterval(() => {
  if (connected) fetchAllHistories();
}, 15000);

// ‚îÄ‚îÄ Handle page visibility ‚îÄ‚îÄ
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && ws && ws.readyState !== WebSocket.OPEN) {
    connectGateway();
  }
});
</script>
</body>
</html>
